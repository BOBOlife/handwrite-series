// 提高复用性的目的
// 1. 遵循DRY原则
// 2. 减少代码量，节省开销

//  什么事好的复用
// 1. 对象可以再重复使用
// 2. 重复代码少
// 3. 模块功能单一


// 桥接模式 
// 通过桥接代替耦合，减少了模块之间的耦合

// 享元模式
// 减少对象/ 代码数量 当代码中创建了大量类似对象和类似的代码块

//模版方法模式
// 定义一系列操作的骨架，简化后后面类似操作的内容 当项目中出现很多类似操作

/*****************************    享元模式     ********************************/
// 有一百种不同文字的弹窗，每种弹窗行为相同，但文字和样式不同，我们没必要新建一百个弹窗对象
function Pop() {

}
// 保留同样的行为
Pop.prototype.action = function () { }
Pop.prototype.show = function () { }

// 提取出每个弹窗会不同的部分作为一个外部数组
const popArr = [
  { text: 'this is window1', style: [400, 400] },
  { text: 'this is window1', style: [400, 400] }
]
const poper = new Pop()
for (let i = 0; i < 100; i++) {
  poper.show(popArr[i])
}

/************************************    桥接模式     **************************************/
function rect(color) {
  showcolor(color)
}
function circle(color) {
  showcolor(color)
}
function showcolor(color) {

}

new circle('red')

/******************************************    模版方法模式    ****************************************************/

// 编写导航组件，有的带消息提示，有的是竖着的，有的是横着的
function baseNav() {
  // 基础类，此处下基本骨架
}
baseNav.prototype.action = function (fn) {
  // 特异性的处理，留一个回调等待具体实现
}

// 总结： 导航组件多种多样，可能后面还会新增类型，那么我们不妨写一个基础的组件类，然后具体的实现，延迟到具体的使用时




// JS 的组合和继承
//组合
// 1. JS 最初没有专门的继承，所以最初Js推崇函数式的编程，然后进行统一组合桥接到一起
// 2. 桥接模式可以看出组合的一种体现，组合的好处是耦合低，方便方法复用，方便扩展


// 继承
// 1. 在es6出现class 和 extend ，继承的方式多种多样，但是都各有弊端
// 2. 模版方法模式可以看出继承的一种体现，继承的好处是可以自动获得父类的内容和接口，方便统一化



